#pragma once

#include <iostream>

#include "antlr4-runtime.h"
#include "automata/nfa/lva.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {
class CharclassVisitor : public REmatchParserBaseVisitor {
public:
  CharclassVisitor(std::shared_ptr<VariableFactory> &_vfact,
                   std::shared_ptr<FilterFactory> &_ffact)
      : vfact(_vfact), ffact(_ffact) {}

  void do_visit(REmatchParser::RootContext *ctx) { visitRoot(ctx); }

private:
  // FIXME: Just for debug
  std::shared_ptr<VariableFactory> vfact;
  std::shared_ptr<FilterFactory> ffact;

  std::any visitLiteral(REmatchParser::LiteralContext *ctx) override {
    std::string text = ctx->getText();
    std::cout << "visitLiteral: " << text << std::endl;

    if (ctx->escapes() || ctx->special()) {
      auto A = std::make_unique<LogicalVA>(ffact->get_code(ctx));
      // FIXME: Just for debug
      A->set_factories(vfact, ffact);
      std::cout << *A << std::endl;
    }
    // ctx->other()
    else {
      auto A = std::make_unique<LogicalVA>(ffact->get_code(text[0]));
      for (size_t i = 1; i < text.size(); ++i) {
        auto B = std::make_unique<LogicalVA>(ffact->get_code(text[i]));
        A->cat(*B);
      }
      // FIXME: Just for debug
      A->set_factories(vfact, ffact);
      std::cout << *A << std::endl;
    }
    return 0;
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext *ctx) override {
    std::cout << "SharedAtom: \"" << ctx->getText() << '"' << std::endl;
    auto A = std::make_unique<LogicalVA>(ffact->get_code(ctx));
    // FIXME: Just for debug
    A->set_factories(vfact, ffact);
    std::cout << *A << std::endl;
    return 0;
  }

  std::any
  visitCharacterClass(REmatchParser::CharacterClassContext *ctx) override {
    std::cout << "CharacterClass: \"" << ctx->getText() << '"' << std::endl;
    return 0;
  }
};
} // namespace visitors
} // namespace rematch