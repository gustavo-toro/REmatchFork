#pragma once

#include "antlr4-runtime.h"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {
class FilterFactoryVisitor : public REmatchParserBaseVisitor {
public:
  FilterFactory get_ffact(REmatchParser::RootContext *ctx) {
    visitRoot(ctx); 
    return ffact;
  }

private:
  FilterFactory ffact;

  std::any visitRoot(REmatchParser::RootContext *ctx) override {
    visit(ctx->alternation());

    return 0;
  }

  std::any visitAlternation(REmatchParser::AlternationContext *ctx) override {
    for (auto &expr : ctx->expr()) {
      visit(expr);
    }

    return 0;
  }

  std::any visitExpr(REmatchParser::ExprContext *ctx) override {
    for (auto &element : ctx->element()) {
      visit(element);
    }

    return 0;
  }

  std::any visitElement(REmatchParser::ElementContext *ctx) override {
    visit(ctx->group());

    return 0;
  }

  std::any visitGroup(REmatchParser::GroupContext *ctx) override {
    if (ctx->parentheses()) {
      visit(ctx->parentheses());
    } else if (ctx->assignation()) {
      visit(ctx->assignation());
    } else if (ctx->atom()) {
      visit(ctx->atom());
    } else {
      throw parsing::BadRegex("Unexpected group derivation");
    }

    return 0;
  }

  std::any visitParentheses(REmatchParser::ParenthesesContext *ctx) override {
    visit(ctx->alternation());

    return 0;
  }

  std::any visitAssignation(REmatchParser::AssignationContext *ctx) override {
    visit(ctx->alternation());

    return 0;
  }

  std::any visitAtom(REmatchParser::AtomContext *ctx) override {
    // ffact.add_filter(ctx);

    return 0;
  }
};
}
}