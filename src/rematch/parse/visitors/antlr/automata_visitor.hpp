#pragma once

#include "antlr4-runtime.h"
#include "automata/nfa/lva.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {

class AutomataVisitor : public REmatchParserBaseVisitor {
public:
  AutomataVisitor(std::shared_ptr<VariableFactory> &_vfact,
                  std::shared_ptr<FilterFactory> &_ffact)
      : vfact(_vfact), ffact(_ffact) {}

  LogicalVA get_lva(REmatchParser::RootContext *ctx) {
    std::any any_lva = visitRoot(ctx);
    LogicalVA lva = std::any_cast<LogicalVA>(any_lva);

    return lva;
  }

private:
  std::shared_ptr<VariableFactory> vfact;
  std::shared_ptr<FilterFactory> ffact;

  std::any visitRoot(REmatchParser::RootContext *ctx) override {
    return visit(ctx->alternation());
  }

  std::any visitAlternation(REmatchParser::AlternationContext *ctx) override {
    std::any A = visit(ctx->expr().front());
    LogicalVA &A_cast = std::any_cast<LogicalVA &>(A);

    size_t children_size = ctx->expr().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->expr(i));
        LogicalVA &rhs_cast = std::any_cast<LogicalVA &>(rhs);
        A_cast.alter(rhs_cast);
      }
    }

    return A;
  }

  std::any visitExpr(REmatchParser::ExprContext *ctx) override {
    std::any A = visit(ctx->element().front());
    LogicalVA &A_cast = std::any_cast<LogicalVA &>(A);

    size_t children_size = ctx->element().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->element(i));
        LogicalVA &rhs_cast = std::any_cast<LogicalVA &>(rhs);
        A_cast.cat(rhs_cast);
      }
    }

    return A;
  }

  std::any visitElement(REmatchParser::ElementContext *ctx) override {
    std::any A = visit(ctx->group());
    LogicalVA &A_cast = std::any_cast<LogicalVA &>(A);

    auto quantifier = ctx->quantifier();
    if (quantifier) {
      if (quantifier->QUESTION()) {
        A_cast.optional();
      } else if (quantifier->STAR()) {
        A_cast.kleene();
      } else if (quantifier->PLUS()) {
        A_cast.strict_kleene();
      }
      // TODO: rest of quantitifers
    }

    return A;
  }

  std::any visitGroup(REmatchParser::GroupContext *ctx) override {
    std::any A;

    if (ctx->parentheses()) {
      A = visit(ctx->parentheses());
    } else if (ctx->assignation()) {
      A = visit(ctx->assignation());
    } else {
      A = visit(ctx->atom());
    }

    return A;
  }

  std::any visitParentheses(REmatchParser::ParenthesesContext *ctx) override {
    return visit(ctx->alternation());
  }

  std::any visitAssignation(REmatchParser::AssignationContext *ctx) override {
    std::any A = visit(ctx->alternation());
    LogicalVA &A_cast = std::any_cast<LogicalVA &>(A);

    std::string var = ctx->VARNAME()->getText();
    std::bitset<32> op_code = vfact->open_code(var);
    std::bitset<32> cl_code = vfact->close_code(var);
    A_cast.assign(op_code, cl_code);

    return A;
  }

  std::any visitAtom(REmatchParser::AtomContext *ctx) override {
    std::any A;

    if (ctx->literal()) {
      A = visit(ctx->literal());
    } else if (ctx->sharedAtom()) {
      A = visit(ctx->sharedAtom());
    } else {
      A = visit(ctx->characterClass());
    }

    return A;
  }

  std::any visitLiteral(REmatchParser::LiteralContext *ctx) override {
    int code = ffact->get_code(ctx);
    return std::make_any<LogicalVA>(code);
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext *ctx) override {
    int code = ffact->get_code(ctx);
    return std::make_any<LogicalVA>(code);
  }

  std::any
  visitCharacterClass(REmatchParser::CharacterClassContext *ctx) override {
    int code = ffact->get_code(ctx);
    return std::make_any<LogicalVA>(code);
  }
};
} // namespace visitors
} // namespace rematch