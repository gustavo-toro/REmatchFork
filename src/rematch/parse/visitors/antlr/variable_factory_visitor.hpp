#pragma once

#include "antlr4-runtime.h"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {

class VariableFactoryVisitor : public REmatchParserBaseVisitor {
public:
  VariableFactory create_vfact(REmatchParser::RootContext *ctx) {
    return std::any_cast<VariableFactory>(visitRoot(ctx));
  }

private:
  std::any visitRoot(REmatchParser::RootContext *ctx) override {
    return visit(ctx->alternation());
  }

  std::any visitAlternation(REmatchParser::AlternationContext *ctx) override {
    std::any vfact = visit(ctx->expr().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->expr().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->expr(i));
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        // TODO: Ask if this is correct
        // The array-output branch merges alterns, while
        // the antlr4 branch just throws an error
        // if (!(vfact_cast == rhs_cast)) {
        //   throw parsing::BadRegex("Alternation variables differ");
        // }
        vfact_cast.merge(rhs_cast);
      }
    }

    return vfact;
  }

  std::any visitExpr(REmatchParser::ExprContext *ctx) override {
    std::any vfact = visit(ctx->element().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->element().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->element()[i]);
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        vfact_cast.merge(rhs_cast);
      }
    }

    return vfact;
  }

  std::any visitElement(REmatchParser::ElementContext *ctx) override {
    return visit(ctx->group());
  }

  std::any visitGroup(REmatchParser::GroupContext *ctx) override {
    std::any vfact;

    if (ctx->parenthesis()) {
      vfact = visit(ctx->parenthesis());
    } else if (ctx->assignation()) {
      vfact = visit(ctx->assignation());
    } else if (ctx->atom()) {
      vfact = visit(ctx->atom());
    } else {
      throw parsing::BadRegex("Unexpected group derivation");
    }

    return vfact;
  }

  std::any visitParenthesis(REmatchParser::ParenthesisContext *ctx) override {
    return visit(ctx->alternation());
  }

  std::any visitAssignation(REmatchParser::AssignationContext *ctx) override {
    std::any vfact = visit(ctx->alternation());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    std::string var = ctx->variable()->getText();

    if (vfact_cast.contains(var)) {
      throw parsing::BadRegex("Nested the same variables inside asignations");
    }
    vfact_cast.add(var);

    return vfact;
  }

  std::any visitAtom(REmatchParser::AtomContext * /*ctx*/) override {
    return std::make_any<VariableFactory>();
  }
};
} // namespace visitors
} // namespace rematch