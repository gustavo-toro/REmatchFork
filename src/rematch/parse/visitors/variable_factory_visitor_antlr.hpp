#pragma once

#include <string>

#include "antlr4-runtime.h"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {

class VariableFactoryVisitor : public REmatchParserBaseVisitor {
 public:
  std::any visitRoot(REmatchParser::RootContext *ctx) final {
    auto vfact = visit(ctx->altern());

    return vfact;
  }

  std::any visitAltern(REmatchParser::AlternContext *ctx) final {
    std::any vfact = visit(ctx->concat().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->concat().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->concat()[i]);
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        if (!(vfact_cast == rhs_cast)) {
          throw parsing::BadRegex("Not a functional regex. (altern)");
        }
      }
    }

    return vfact;
  }

  std::any visitConcat(REmatchParser::ConcatContext *ctx) final {
    std::any vfact = visit(ctx->iter().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->iter().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->iter()[i]);
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        vfact_cast.merge(rhs_cast);
      }
    }

    return vfact;
  }

  std::any visitIter(REmatchParser::IterContext *ctx) final {
    std::any vfact = visit(ctx->group());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    if (ctx->rep() != nullptr && !vfact_cast.empty()) {
      throw parsing::BadRegex("Not a functional regex. (iter)");
    }

    return vfact;
  }

  std::any visitGroup(REmatchParser::GroupContext *ctx) final {
    if (ctx->parenthesis() != nullptr) {
      return visit(ctx->parenthesis());
    } else if (ctx->assign() != nullptr) {
      return visit(ctx->assign());
    } else if (ctx->atom() != nullptr) {
      return visit(ctx->atom());
    }
  }

  std::any visitParenthesis(REmatchParser::ParenthesisContext *ctx) final {
    std::any vfact = visit(ctx->altern());

    return vfact;
  }

  std::any visitAssign(REmatchParser::AssignContext *ctx) final {
    std::any vfact = visit(ctx->altern());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    if (vfact_cast.contains(ctx->VARNAME()->getText())) {
      throw parsing::BadRegex("Not a functional regex. (assign)");
    }
    vfact_cast.add(ctx->VARNAME()->getText());

    return vfact;
  }

  std::any visitAtom(REmatchParser::AtomContext *ctx) final {
    return std::make_any<VariableFactory>();
  }
};

}  // namespace rematch