#pragma once

#include "antlr4-runtime.h"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {

class VariableFactoryVisitor : public REmatchParserBaseVisitor {
 public:
  std::any visitRoot(REmatchParser::RootContext *ctx) final {
    auto vfact = visit(ctx->alternation());

    return vfact;
  }

  std::any visitAlternation(REmatchParser::AlternationContext *ctx) final {
    std::any vfact = visit(ctx->expr().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->expr().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->expr()[i]);
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        if (!(vfact_cast == rhs_cast)) {
          throw parsing::BadRegex("Alternation variables differ");
        }
      }
    }

    return vfact;
  }

  std::any visitExpr(REmatchParser::ExprContext *ctx) final {
    std::any vfact = visit(ctx->element().front());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    size_t children_size = ctx->element().size();
    if (children_size > 1) {
      for (size_t i = 1; i < children_size; i++) {
        std::any rhs = visit(ctx->element()[i]);
        VariableFactory &rhs_cast = std::any_cast<VariableFactory &>(rhs);
        vfact_cast.merge(rhs_cast);
      }
    }

    return vfact;
  }

  std::any visitElement(REmatchParser::ElementContext *ctx) final {
    std::any vfact = visit(ctx->group());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    if (ctx->quantifier() != nullptr && !vfact_cast.empty()) {
      throw parsing::BadRegex("Quantifier cannot be applied to a variable");
    }

    return vfact;
  }

  std::any visitGroup(REmatchParser::GroupContext *ctx) final {
    std::any vfact;

    if (ctx->parenthesis() != nullptr) {
      vfact = visit(ctx->parenthesis());
    } else if (ctx->assignation() != nullptr) {
      vfact = visit(ctx->assignation());
    } else if (ctx->atom() != nullptr) {
      vfact = visit(ctx->atom());
    }

    return vfact;
  }

  std::any visitParenthesis(REmatchParser::ParenthesisContext *ctx) final {
    std::any vfact = visit(ctx->alternation());

    return vfact;
  }

  std::any visitAssignation(REmatchParser::AssignationContext *ctx) final {
    std::any vfact = visit(ctx->alternation());
    VariableFactory &vfact_cast = std::any_cast<VariableFactory &>(vfact);

    if (vfact_cast.contains(ctx->variable()->getText())) {
      throw parsing::BadRegex("Same variable assigned twice in the same group");
    }
    vfact_cast.add(ctx->variable()->getText());

    return vfact;
  }

  std::any visitAtom(REmatchParser::AtomContext *ctx) final {
    return std::make_any<VariableFactory>();
  }
};
}  // namespace rematch