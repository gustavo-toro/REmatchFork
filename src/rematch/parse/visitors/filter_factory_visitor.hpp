#pragma once

#include "antlr4-runtime.h"
#include "automata/nfa/lva.hpp"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {
class FilterFactoryVisitor : public REmatchParserBaseVisitor {
 public:
  std::shared_ptr<VariableFactory> vfact_ptr;
  std::shared_ptr<FilterFactory> ffact_ptr;
  std::unique_ptr<LogicalVA> lva_ptr;

  FilterFactoryVisitor(std::shared_ptr<VariableFactory> _vfact_ptr)
      : vfact_ptr(_vfact_ptr), ffact_ptr(std::make_shared<FilterFactory>()) {}

 private:
  std::any visitAlternation(REmatchParser::AlternationContext* ctx) override {
    // Build the automaton for the first expression
    visit(ctx->expr(0));
    auto lhs = std::move(lva_ptr);
    // Alternate the remaining expressions
    for (size_t i = 1; i < ctx->expr().size(); ++i) {
      visit(ctx->expr(i));
      lhs->alter(*lva_ptr);
    }
    lva_ptr = std::move(lhs);

    return 0;
  }

  std::any visitExpr(REmatchParser::ExprContext* ctx) override {
    // Build the automaton for the first element
    visit(ctx->element(0));
    auto lhs = std::move(lva_ptr);
    // Concatenate the remaining elements
    for (size_t i = 1; i < ctx->element().size(); ++i) {
      visit(ctx->element(i));
      lhs->cat(*lva_ptr);
    }
    lva_ptr = std::move(lhs);

    return 0;
  }

  std::any visitElement(REmatchParser::ElementContext* ctx) override {
    // Build the automaton for the group
    visit(ctx->group());
    // Apply the quantifier
    auto quantifier = ctx->quantifier();
    if (quantifier) {
      visit(quantifier);
    }

    return 0;
  }

  std::any visitGroup(REmatchParser::GroupContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitQuantifier(REmatchParser::QuantifierContext* ctx) override {
    if (ctx->QUESTION()) {
      lva_ptr->optional();
    } else if (ctx->PLUS()) {
      lva_ptr->strict_kleene();
    } else if (ctx->STAR()) {
      lva_ptr->kleene();
    }
    // Quantifier range
    else {
      auto qty = ctx->quantity();
      int lo = 0, hi = -1;
      if (qty->quantExact()) {
        lo = std::stoi(qty->getText());
        hi = lo;
      } else if (qty->quantRange()) {
        lo = std::stoi(qty->quantRange()->number(0)->getText());
        hi = std::stoi(qty->quantRange()->number(1)->getText());
      } else if (qty->quantMin()) {
        lo = std::stoi(qty->getText());
      } else if (qty->quantMax()) {
        hi = std::stoi(qty->getText());
      }
      lva_ptr->repeat(lo, hi);
    }

    return 0;
  }

  std::any visitParentheses(REmatchParser::ParenthesesContext* ctx) override {
    visit(ctx->alternation());

    return 0;
  }

  std::any visitAssignation(REmatchParser::AssignationContext* ctx) override {
    // Build the automaton for the alternation
    visit(ctx->alternation());
    // Assign the codes from the variable
    std::string var = ctx->varname()->getText();
    std::bitset<32> op_code = vfact_ptr->open_code(var);
    std::bitset<32> cl_code = vfact_ptr->close_code(var);
    lva_ptr->assign(op_code, cl_code);

    return 0;
  }

  std::any visitAtom(REmatchParser::AtomContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitLiteral(REmatchParser::LiteralContext* ctx) override {
    if (ctx->escapes()) {
      // Ignore the starting backslash
      int code = ffact_ptr->add_filter(ctx->getText()[1]);
      lva_ptr = std::make_unique<LogicalVA>(code);
    } else if (ctx->special()) {
      auto sp = ctx->special();
      if (sp->DOT()) {
        // TODO: Handle dot for unicode characters
        int code = ffact_ptr->add_filter({0, CHAR_MAX});
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else if (sp->TAB()) {
        int code = ffact_ptr->add_filter('\t');
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else if (sp->CARRIAGE_RETURN()) {
        int code = ffact_ptr->add_filter('\r');
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else if (sp->NEWLINE()) {
        int code = ffact_ptr->add_filter('\n');
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else if (sp->VERTICAL_WHITESPACE()) {
        int code = ffact_ptr->add_filter('\v');
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else if (sp->FORM_FEED()) {
        int code = ffact_ptr->add_filter('\f');
        lva_ptr = std::make_unique<LogicalVA>(code);
      } else {
        throw parsing::BadRegex("Unhandled Special Literal: " + sp->getText());
      }
    }
    // Other literals
    else {
      std::string text = ctx->getText();
      // Build the automaton for the first character
      int code = ffact_ptr->add_filter(text[0]);
      lva_ptr = std::make_unique<LogicalVA>(code);
      // Concatenate the remaining characters
      for (size_t i = 1; i < text.size(); ++i) {
        int code = ffact_ptr->add_filter(text[i]);
        auto rhs = std::make_unique<LogicalVA>(code);
        lva_ptr->cat(*rhs);
      }
    }

    return 0;
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext*) override {
    throw std::runtime_error("Character shared atoms are not supported yet");
  }

  std::any visitCharacterClass(REmatchParser::CharacterClassContext*) override {
    throw std::runtime_error("Character classes are not supported yet");
  }
};
}  // namespace visitors
}  // namespace rematch