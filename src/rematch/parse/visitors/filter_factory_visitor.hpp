#pragma once

#include "antlr4-runtime.h"
#include "automata/nfa/lva.hpp"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {
class FilterFactoryVisitor : public REmatchParserBaseVisitor {
 public:
  std::shared_ptr<VariableFactory> vfact_ptr;
  std::shared_ptr<FilterFactory> ffact_ptr;
  std::unique_ptr<LogicalVA> lva_ptr;

  FilterFactoryVisitor(std::shared_ptr<VariableFactory> _vfact_ptr)
      : vfact_ptr(_vfact_ptr), ffact_ptr(std::make_shared<FilterFactory>()) {}

 private:
  std::any visitAlternation(REmatchParser::AlternationContext* ctx) override {
    // Build the automaton for the first expression
    visit(ctx->expr(0));
    auto A = std::move(lva_ptr);
    // Alternate the remaining expressions
    for (size_t i = 1; i < ctx->expr().size(); ++i) {
      visit(ctx->expr(i));
      A->alter(*lva_ptr);
    }
    lva_ptr = std::move(A);

    return 0;
  }

  std::any visitExpr(REmatchParser::ExprContext* ctx) override {
    // Build the automaton for the first element
    visit(ctx->element(0));
    auto A = std::move(lva_ptr);
    // Concatenate the remaining elements
    for (size_t i = 1; i < ctx->element().size(); ++i) {
      visit(ctx->element(i));
      A->cat(*lva_ptr);
    }
    lva_ptr = std::move(A);

    return 0;
  }

  std::any visitElement(REmatchParser::ElementContext* ctx) override {
    // Build the automaton for the group
    visit(ctx->group());
    // Apply the quantifier
    auto quantifier = ctx->quantifier();
    if (quantifier) {
      visit(quantifier);
    }

    return 0;
  }

  std::any visitGroup(REmatchParser::GroupContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitQuantifier(REmatchParser::QuantifierContext* ctx) override {
    if (ctx->QUESTION()) {
      lva_ptr->optional();
    } else if (ctx->PLUS()) {
      lva_ptr->strict_kleene();
    } else if (ctx->STAR()) {
      lva_ptr->kleene();
    }
    // Quantifier range
    else {
      auto qty = ctx->quantity();
      int lo = 0, hi = -1;
      if (qty->quantExact()) {
        lo = std::stoi(qty->getText());
        hi = lo;
      } else if (qty->quantRange()) {
        lo = std::stoi(qty->quantRange()->number(0)->getText());
        hi = std::stoi(qty->quantRange()->number(1)->getText());
      } else if (qty->quantMin()) {
        lo = std::stoi(qty->getText());
      } else if (qty->quantMax()) {
        hi = std::stoi(qty->getText());
      }
      lva_ptr->repeat(lo, hi);
    }

    return 0;
  }

  std::any visitParentheses(REmatchParser::ParenthesesContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitAssignation(REmatchParser::AssignationContext* ctx) override {
    // Build the automaton for the alternation
    visit(ctx->alternation());
    // Assign the codes from the variable
    std::string var = ctx->varname()->getText();
    std::bitset<32> op_code = vfact_ptr->open_code(var);
    std::bitset<32> cl_code = vfact_ptr->close_code(var);
    lva_ptr->assign(op_code, cl_code);

    return 0;
  }

  std::any visitAtom(REmatchParser::AtomContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitLiteral(REmatchParser::LiteralContext* ctx) override {
    visitChildren(ctx);

    return 0;
  }

  std::any visitEscapes(REmatchParser::EscapesContext* ctx) override {
    // Ignore the starting backslash
    lva_ptr =
        std::make_unique<LogicalVA>(ffact_ptr->add_filter(ctx->getText()[1]));

    return 0;
  }

  std::any visitSpecial(REmatchParser::SpecialContext* ctx) override {
    // Dot (Any Operator) needs to be handled for UTF-8 literals
    if (ctx->DOT()) {
      // 1 byte automaton
      auto A1 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x00', '\x7F'}));
      // 2 bytes automaton
      auto B1 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\xC2', '\xDF'}));
      auto B2 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      B1->cat(*B2);
      // 3 bytes automaton
      auto C1 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\xE0', '\xEF'}));
      auto C2 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      auto C3 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      C1->cat(*C2);
      C1->cat(*C3);
      // 4 bytes automaton
      auto D1 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\xF0', '\xF7'}));
      auto D2 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      auto D3 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      auto D4 = std::make_unique<LogicalVA>(ffact_ptr->add_filter({'\x80', '\xBF'}));
      D1->cat(*D2);
      D1->cat(*D3);
      D1->cat(*D4);
      // Alternate all the automata
      A1->alter(*B1);
      A1->alter(*C1);
      A1->alter(*D1);

      lva_ptr = std::move(A1);

      return 0;
    }
    // Regular special literals
    else if (ctx->TAB()) {
      lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter('\t'));
    } else if (ctx->CARRIAGE_RETURN()) {
      lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter('\r'));
    } else if (ctx->NEWLINE()) {
      lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter('\n'));
    } else if (ctx->VERTICAL_WHITESPACE()) {
      lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter('\v'));
    } else if (ctx->FORM_FEED()) {
      lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter('\f'));
    } else {
      throw parsing::BadRegex("Unhandled Special Literal: " + ctx->getText());
    }

    return 0;
  }

  std::any visitOther(REmatchParser::OtherContext* ctx) override {
    std::string text = ctx->getText();
    // Build the automaton for the first character
    lva_ptr = std::make_unique<LogicalVA>(ffact_ptr->add_filter(text[0]));
    // Concatenate the remaining characters
    for (size_t i = 1; i < text.size(); ++i) {
      auto A = std::make_unique<LogicalVA>(ffact_ptr->add_filter(text[i]));
      lva_ptr->cat(*A);
    }

    return 0;
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext*) override {
    throw std::runtime_error("Character shared atoms are not supported yet");
  }

  std::any visitCharacterClass(REmatchParser::CharacterClassContext*) override {
    throw std::runtime_error("Character classes are not supported yet");
  }
};
}  // namespace visitors
}  // namespace rematch