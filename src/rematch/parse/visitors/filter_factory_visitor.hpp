#pragma once

#include "antlr4-runtime.h"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

namespace rematch {
namespace visitors {
class FilterFactoryVisitor : public REmatchParserBaseVisitor {
public:
  std::shared_ptr<FilterFactory> ffact_ptr;
  std::unique_ptr<LogicalVA>     lva_ptr;

  FilterFactoryVisitor() : ffact_ptr(std::make_shared<FilterFactory>()) {}
private:
  // TODO: implement cat, altern, etc

  std::any visitLiteral(REmatchParser::LiteralContext *ctx) override {
    std::cout << "visitLiteral:" << ctx->getText() << std::endl;
    if (ctx->special() || ctx->escapes()) {
      int code = ffact_ptr->add_filter(ctx);
      lva_ptr  = std::make_unique<LogicalVA>(code);
    }
    // ctx->other()
    else {
      std::string text = ctx->getText();
      // Build the main automaton with the first character
      int code = ffact_ptr->add_filter(text[0]);
      auto A   = std::make_unique<LogicalVA>(code);
      // Concatenate the remaining characters
      for (size_t i = 1; i < text.size(); ++i) {
        int code = ffact_ptr->add_filter(text[i]);
        auto B   = std::make_unique<LogicalVA>(code);
        A->cat(*B);
      }
      lva_ptr = std::move(A);
    }
    return 0;
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext *ctx) override {
    int code = ffact_ptr->add_filter(ctx);
    lva_ptr  = std::make_unique<LogicalVA>(code);
    return 0;
  }

  std::any visitCcRange(REmatchParser::CcRangeContext *ctx) override {
    throw std::runtime_error("Character class ranges are not supported yet");
    return 0;
  }

  std::any visitCharacterClass(REmatchParser::CharacterClassContext *ctx) override {
    auto ccAtom = ctx->ccAtom();
    // Build the main automaton with the first character class atom
    visit(ccAtom[0]);
    auto A = std::move(lva_ptr);
    // Alternation of the remaining ccAtoms
    for (size_t i = 1; i < ccAtom.size(); ++i) {
      visit(ccAtom[i]);
      A->alter(*lva_ptr);
    }
    lva_ptr = std::move(A);
    return 0;
  }
};
} // namespace visitors
} // namespace rematch