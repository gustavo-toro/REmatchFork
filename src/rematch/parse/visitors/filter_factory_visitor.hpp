#pragma once

#include "antlr4-runtime.h"
#include "automata/nfa/lva.hpp"
#include "exceptions.hpp"
#include "factories/factories.hpp"
#include "parse/grammar/autogenerated/REmatchParserBaseVisitor.h"

// TODO: Move this to a separate file
// struct Int32Range {
//   Int32Range() : lo(0), hi(0) {}
//   Int32Range(int l, int h) : lo(l), hi(h) {}

//   bool operator==(const Int32Range &other) const { return lo == other.lo && hi == other.hi; }

//   int32_t lo;
//   int32_t hi;
// };

// struct Int32RangeLess {
//   bool operator()(const Int32Range &a, const Int32Range &b) const {
//     return a.hi < b.lo;
//   }
// };

// using Int32RangeSet = std::set<Int32Range, Int32RangeLess>;

namespace rematch {
namespace visitors {
class FilterFactoryVisitor : public REmatchParserBaseVisitor {
public:
  std::shared_ptr<FilterFactory> ffact_ptr;
  std::unique_ptr<LogicalVA>     lva_ptr;

  FilterFactoryVisitor() : ffact_ptr(std::make_shared<FilterFactory>()) {}
private:
  // TODO: implement cat, altern, etc

  uint32_t utf8StrToInt32(const std::string &str) {
    size_t size = str.size();
    switch (size) {
      case 1:
        return str[0] & 0x7F;
      case 2:
        return ((str[0] & 0x1F) << 6) | (str[1] & 0x3F);
      case 3:
        return ((str[0] & 0x0F) << 12) | ((str[1] & 0x3F) << 6) | (str[2] & 0x3F);
      case 4:
        return ((str[0] & 0x07) << 18) | ((str[1] & 0x3F) << 12) | ((str[2] & 0x3F) << 6) | (str[3] & 0x3F);
      default:
        throw std::runtime_error("Invalid UTF-8 string");
    }
  }

  std::any visitLiteral(REmatchParser::LiteralContext *ctx) override {
    std::cout << "visitLiteral:" << ctx->getText() << std::endl;
    if (ctx->special() || ctx->escapes()) {
      int code = ffact_ptr->add_filter(ctx);
      lva_ptr  = std::make_unique<LogicalVA>(code);
    }
    // ctx->other()
    else {
      std::string text = ctx->getText();
      // Build the main automaton with the first character
      int code = ffact_ptr->add_filter(text[0]);
      auto A   = std::make_unique<LogicalVA>(code);
      // Concatenate the remaining characters
      for (size_t i = 1; i < text.size(); ++i) {
        int code = ffact_ptr->add_filter(text[i]);
        auto B   = std::make_unique<LogicalVA>(code);
        A->cat(*B);
      }
      lva_ptr = std::move(A);
    }
    return 0;
  }

  std::any visitSharedAtom(REmatchParser::SharedAtomContext *ctx) override {
    int code = ffact_ptr->add_filter(ctx);
    lva_ptr  = std::make_unique<LogicalVA>(code);
    return 0;
  }

  std::any visitCcRange(REmatchParser::CcRangeContext *ctx) override {
    throw std::runtime_error("Character class ranges are not supported yet");
    return 0;
  }

  std::any visitCharacterClass(REmatchParser::CharacterClassContext *ctx) override {
    // 1. Convert the ccAtoms into integer ranges
    int32_t lo = 0, hi = 0;
    for (auto& ccAtom : ctx->ccAtom()) {
      if (ccAtom->literal()) {
        lo = hi = utf8StrToInt32(ccAtom->getText());
      }
      else if (ccAtom->ccRange()) {
        auto ccLiteralLo = ccAtom->ccRange()->ccLiteral(0);
        auto ccLiteralHi = ccAtom->ccRange()->ccLiteral(1);
        // Lower bound
        if (ccLiteralLo->ccEscapes()) {
          lo = ccLiteralLo->getText()[1] & 0x7F;
        }
        else {
          lo = utf8StrToInt32(ccLiteralLo->getText());
        }
        // Upper bound
        if (ccLiteralHi->ccEscapes()) {
          hi = ccLiteralHi->ccEscapes()->getText()[1] & 0x7F;
        }
        else {
          hi = utf8StrToInt32(ccLiteralHi->getText());
        }
      }
      else if (ccAtom->sharedAtom()) {
        throw std::runtime_error("Shared Atoms inside Character Classes are not supported yet");
      }
      // assert(lo <= hi);
      std::cout << ccAtom->getText() << " LO:" << lo <<  " HI:" << hi << std::endl;
    }
    // auto ccAtom = ctx->ccAtom();
    // Build the main automaton with the first character class atom
    // visit(ccAtom[0]);
    // auto A = std::move(lva_ptr);
    // Alternation of the remaining ccAtoms
    // for (size_t i = 1; i < ccAtom.size(); ++i) {
      // visit(ccAtom[i]);
      // A->alter(*lva_ptr);
    // }
    // lva_ptr = std::move(A);
    return 0;
  }
};
} // namespace visitors
} // namespace rematch